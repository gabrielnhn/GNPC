(Verifique README.md para ver como compilar e usar o compilador)

Ideia original para a inclusão de declarações forward:
    Função ou procedimento está marcado como forward?
        Se não: continua normalmente
        Se sim: se separa um rótulo para a função. Quando sua implementação for vista, usa-se este rótulo.

    No fim do programa:
        Se falta a implementação de alguma função: erro()

A ideia original falta apenas alguns detalhes: 
    Quando o header é lido e a função é forwarded, todos os símbolos provenientes da função
    devem ser jogados fora, como se a função realmente tivesse sido processada. As únicas 
    informações que devem ficar na tabela são informações sobre o procedimento ou
    função para que a função possa ser chamada mesmo sem ter processado sua implementação.

Mais algumas alterações foram feitas, majoritariamente na regra 'procedure_def':
    * Como agora se pode realizar a implementação de uma função que
        não é a última função da tabela de símbolos, se utiliza uma stack para definir 
        qual dos procedimentos que está sendo processado, ao invés de apenas passar pela 
        tabelas de símbolos buscando pelo último procedimento.

    * Uma outra pilha, 'no_implementation_stack', é usada para ver se existe algum procedimento 
        forwarded que NÃO teve implementação, acusando erro no fim da compilação caso exista.

Alterações desta versão do compilador em relação ao Original que não tem a ver com 
    a implementação do comando forward mas sim sobre a formatação dos arquivos forward*.pas: 

    * A opção de chamar e declarar "procedimento()", sem parâmetros, mas com abre e fecha parenteses.
        Anteriormente, caso a função/procedimento não tivesse parâmetros,
        somente "PROCEDIMENTO;" sem "()" era possível.

    * o token "Program" é agora case-insensitive.

    * writeln() agora tem implementação, e é igual a write().

    